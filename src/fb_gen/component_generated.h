// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMPONENT_INCEPTION_FB_H_
#define FLATBUFFERS_GENERATED_COMPONENT_INCEPTION_FB_H_

#include "flatbuffers/flatbuffers.h"

namespace Inception {
namespace fb {

struct icpGuid;
struct icpGuidBuilder;

struct Vector3;
struct Vector3Builder;

struct Quaternion;
struct QuaternionBuilder;

struct Matrix4x4;
struct Matrix4x4Builder;

struct icpEntityDataComponent;
struct icpEntityDataComponentBuilder;

struct icpXFromComponent;
struct icpXFromComponentBuilder;

struct icpCameraComponent;
struct icpCameraComponentBuilder;

struct icpMeshRendererComponent;
struct icpMeshRendererComponentBuilder;

inline const flatbuffers::TypeTable *icpGuidTypeTable();

inline const flatbuffers::TypeTable *Vector3TypeTable();

inline const flatbuffers::TypeTable *QuaternionTypeTable();

inline const flatbuffers::TypeTable *Matrix4x4TypeTable();

inline const flatbuffers::TypeTable *icpEntityDataComponentTypeTable();

inline const flatbuffers::TypeTable *icpXFromComponentTypeTable();

inline const flatbuffers::TypeTable *icpCameraComponentTypeTable();

inline const flatbuffers::TypeTable *icpMeshRendererComponentTypeTable();

enum icpComponentBase : uint8_t {
  icpComponentBase_NONE = 0,
  icpComponentBase_icpEntityDataComponent = 1,
  icpComponentBase_icpXFromComponent = 2,
  icpComponentBase_icpCameraComponent = 3,
  icpComponentBase_icpMeshRendererComponent = 4,
  icpComponentBase_MIN = icpComponentBase_NONE,
  icpComponentBase_MAX = icpComponentBase_icpMeshRendererComponent
};

inline const icpComponentBase (&EnumValuesicpComponentBase())[5] {
  static const icpComponentBase values[] = {
    icpComponentBase_NONE,
    icpComponentBase_icpEntityDataComponent,
    icpComponentBase_icpXFromComponent,
    icpComponentBase_icpCameraComponent,
    icpComponentBase_icpMeshRendererComponent
  };
  return values;
}

inline const char * const *EnumNamesicpComponentBase() {
  static const char * const names[6] = {
    "NONE",
    "icpEntityDataComponent",
    "icpXFromComponent",
    "icpCameraComponent",
    "icpMeshRendererComponent",
    nullptr
  };
  return names;
}

inline const char *EnumNameicpComponentBase(icpComponentBase e) {
  if (flatbuffers::IsOutRange(e, icpComponentBase_NONE, icpComponentBase_icpMeshRendererComponent)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesicpComponentBase()[index];
}

template<typename T> struct icpComponentBaseTraits {
  static const icpComponentBase enum_value = icpComponentBase_NONE;
};

template<> struct icpComponentBaseTraits<Inception::fb::icpEntityDataComponent> {
  static const icpComponentBase enum_value = icpComponentBase_icpEntityDataComponent;
};

template<> struct icpComponentBaseTraits<Inception::fb::icpXFromComponent> {
  static const icpComponentBase enum_value = icpComponentBase_icpXFromComponent;
};

template<> struct icpComponentBaseTraits<Inception::fb::icpCameraComponent> {
  static const icpComponentBase enum_value = icpComponentBase_icpCameraComponent;
};

template<> struct icpComponentBaseTraits<Inception::fb::icpMeshRendererComponent> {
  static const icpComponentBase enum_value = icpComponentBase_icpMeshRendererComponent;
};

bool VerifyicpComponentBase(flatbuffers::Verifier &verifier, const void *obj, icpComponentBase type);
bool VerifyicpComponentBaseVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct icpGuid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef icpGuidBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return icpGuidTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_GUID = 4
  };
  uint64_t m_guid() const {
    return GetField<uint64_t>(VT_M_GUID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_M_GUID, 8) &&
           verifier.EndTable();
  }
};

struct icpGuidBuilder {
  typedef icpGuid Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_guid(uint64_t m_guid) {
    fbb_.AddElement<uint64_t>(icpGuid::VT_M_GUID, m_guid, 0);
  }
  explicit icpGuidBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<icpGuid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<icpGuid>(end);
    return o;
  }
};

inline flatbuffers::Offset<icpGuid> CreateicpGuid(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t m_guid = 0) {
  icpGuidBuilder builder_(_fbb);
  builder_.add_m_guid(m_guid);
  return builder_.Finish();
}

struct Vector3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Vector3Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vector3TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           verifier.EndTable();
  }
};

struct Vector3Builder {
  typedef Vector3 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Vector3::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Vector3::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Vector3::VT_Z, z, 0.0f);
  }
  explicit Vector3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Vector3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector3>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector3> CreateVector3(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  Vector3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Quaternion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuaternionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuaternionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8,
    VT_W = 10
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  float w() const {
    return GetField<float>(VT_W, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           VerifyField<float>(verifier, VT_W, 4) &&
           verifier.EndTable();
  }
};

struct QuaternionBuilder {
  typedef Quaternion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Quaternion::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Quaternion::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Quaternion::VT_Z, z, 0.0f);
  }
  void add_w(float w) {
    fbb_.AddElement<float>(Quaternion::VT_W, w, 0.0f);
  }
  explicit QuaternionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quaternion> CreateQuaternion(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    float w = 0.0f) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_w(w);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Matrix4x4 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Matrix4x4Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Matrix4x4TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_DATA0 = 4,
    VT_M_DATA1 = 6,
    VT_M_DATA2 = 8,
    VT_M_DATA3 = 10,
    VT_M_DATA4 = 12,
    VT_M_DATA5 = 14,
    VT_M_DATA6 = 16,
    VT_M_DATA7 = 18,
    VT_M_DATA8 = 20,
    VT_M_DATA9 = 22,
    VT_M_DATA10 = 24,
    VT_M_DATA11 = 26,
    VT_M_DATA12 = 28,
    VT_M_DATA13 = 30,
    VT_M_DATA14 = 32,
    VT_M_DATA15 = 34
  };
  float m_data0() const {
    return GetField<float>(VT_M_DATA0, 0.0f);
  }
  float m_data1() const {
    return GetField<float>(VT_M_DATA1, 0.0f);
  }
  float m_data2() const {
    return GetField<float>(VT_M_DATA2, 0.0f);
  }
  float m_data3() const {
    return GetField<float>(VT_M_DATA3, 0.0f);
  }
  float m_data4() const {
    return GetField<float>(VT_M_DATA4, 0.0f);
  }
  float m_data5() const {
    return GetField<float>(VT_M_DATA5, 0.0f);
  }
  float m_data6() const {
    return GetField<float>(VT_M_DATA6, 0.0f);
  }
  float m_data7() const {
    return GetField<float>(VT_M_DATA7, 0.0f);
  }
  float m_data8() const {
    return GetField<float>(VT_M_DATA8, 0.0f);
  }
  float m_data9() const {
    return GetField<float>(VT_M_DATA9, 0.0f);
  }
  float m_data10() const {
    return GetField<float>(VT_M_DATA10, 0.0f);
  }
  float m_data11() const {
    return GetField<float>(VT_M_DATA11, 0.0f);
  }
  float m_data12() const {
    return GetField<float>(VT_M_DATA12, 0.0f);
  }
  float m_data13() const {
    return GetField<float>(VT_M_DATA13, 0.0f);
  }
  float m_data14() const {
    return GetField<float>(VT_M_DATA14, 0.0f);
  }
  float m_data15() const {
    return GetField<float>(VT_M_DATA15, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_M_DATA0, 4) &&
           VerifyField<float>(verifier, VT_M_DATA1, 4) &&
           VerifyField<float>(verifier, VT_M_DATA2, 4) &&
           VerifyField<float>(verifier, VT_M_DATA3, 4) &&
           VerifyField<float>(verifier, VT_M_DATA4, 4) &&
           VerifyField<float>(verifier, VT_M_DATA5, 4) &&
           VerifyField<float>(verifier, VT_M_DATA6, 4) &&
           VerifyField<float>(verifier, VT_M_DATA7, 4) &&
           VerifyField<float>(verifier, VT_M_DATA8, 4) &&
           VerifyField<float>(verifier, VT_M_DATA9, 4) &&
           VerifyField<float>(verifier, VT_M_DATA10, 4) &&
           VerifyField<float>(verifier, VT_M_DATA11, 4) &&
           VerifyField<float>(verifier, VT_M_DATA12, 4) &&
           VerifyField<float>(verifier, VT_M_DATA13, 4) &&
           VerifyField<float>(verifier, VT_M_DATA14, 4) &&
           VerifyField<float>(verifier, VT_M_DATA15, 4) &&
           verifier.EndTable();
  }
};

struct Matrix4x4Builder {
  typedef Matrix4x4 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_data0(float m_data0) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA0, m_data0, 0.0f);
  }
  void add_m_data1(float m_data1) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA1, m_data1, 0.0f);
  }
  void add_m_data2(float m_data2) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA2, m_data2, 0.0f);
  }
  void add_m_data3(float m_data3) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA3, m_data3, 0.0f);
  }
  void add_m_data4(float m_data4) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA4, m_data4, 0.0f);
  }
  void add_m_data5(float m_data5) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA5, m_data5, 0.0f);
  }
  void add_m_data6(float m_data6) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA6, m_data6, 0.0f);
  }
  void add_m_data7(float m_data7) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA7, m_data7, 0.0f);
  }
  void add_m_data8(float m_data8) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA8, m_data8, 0.0f);
  }
  void add_m_data9(float m_data9) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA9, m_data9, 0.0f);
  }
  void add_m_data10(float m_data10) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA10, m_data10, 0.0f);
  }
  void add_m_data11(float m_data11) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA11, m_data11, 0.0f);
  }
  void add_m_data12(float m_data12) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA12, m_data12, 0.0f);
  }
  void add_m_data13(float m_data13) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA13, m_data13, 0.0f);
  }
  void add_m_data14(float m_data14) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA14, m_data14, 0.0f);
  }
  void add_m_data15(float m_data15) {
    fbb_.AddElement<float>(Matrix4x4::VT_M_DATA15, m_data15, 0.0f);
  }
  explicit Matrix4x4Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Matrix4x4> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Matrix4x4>(end);
    return o;
  }
};

inline flatbuffers::Offset<Matrix4x4> CreateMatrix4x4(
    flatbuffers::FlatBufferBuilder &_fbb,
    float m_data0 = 0.0f,
    float m_data1 = 0.0f,
    float m_data2 = 0.0f,
    float m_data3 = 0.0f,
    float m_data4 = 0.0f,
    float m_data5 = 0.0f,
    float m_data6 = 0.0f,
    float m_data7 = 0.0f,
    float m_data8 = 0.0f,
    float m_data9 = 0.0f,
    float m_data10 = 0.0f,
    float m_data11 = 0.0f,
    float m_data12 = 0.0f,
    float m_data13 = 0.0f,
    float m_data14 = 0.0f,
    float m_data15 = 0.0f) {
  Matrix4x4Builder builder_(_fbb);
  builder_.add_m_data15(m_data15);
  builder_.add_m_data14(m_data14);
  builder_.add_m_data13(m_data13);
  builder_.add_m_data12(m_data12);
  builder_.add_m_data11(m_data11);
  builder_.add_m_data10(m_data10);
  builder_.add_m_data9(m_data9);
  builder_.add_m_data8(m_data8);
  builder_.add_m_data7(m_data7);
  builder_.add_m_data6(m_data6);
  builder_.add_m_data5(m_data5);
  builder_.add_m_data4(m_data4);
  builder_.add_m_data3(m_data3);
  builder_.add_m_data2(m_data2);
  builder_.add_m_data1(m_data1);
  builder_.add_m_data0(m_data0);
  return builder_.Finish();
}

struct icpEntityDataComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef icpEntityDataComponentBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return icpEntityDataComponentTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_NAME = 4,
    VT_M_GUID = 6
  };
  const flatbuffers::String *m_name() const {
    return GetPointer<const flatbuffers::String *>(VT_M_NAME);
  }
  const Inception::fb::icpGuid *m_guid() const {
    return GetPointer<const Inception::fb::icpGuid *>(VT_M_GUID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_M_NAME) &&
           verifier.VerifyString(m_name()) &&
           VerifyOffset(verifier, VT_M_GUID) &&
           verifier.VerifyTable(m_guid()) &&
           verifier.EndTable();
  }
};

struct icpEntityDataComponentBuilder {
  typedef icpEntityDataComponent Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_name(flatbuffers::Offset<flatbuffers::String> m_name) {
    fbb_.AddOffset(icpEntityDataComponent::VT_M_NAME, m_name);
  }
  void add_m_guid(flatbuffers::Offset<Inception::fb::icpGuid> m_guid) {
    fbb_.AddOffset(icpEntityDataComponent::VT_M_GUID, m_guid);
  }
  explicit icpEntityDataComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<icpEntityDataComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<icpEntityDataComponent>(end);
    return o;
  }
};

inline flatbuffers::Offset<icpEntityDataComponent> CreateicpEntityDataComponent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> m_name = 0,
    flatbuffers::Offset<Inception::fb::icpGuid> m_guid = 0) {
  icpEntityDataComponentBuilder builder_(_fbb);
  builder_.add_m_guid(m_guid);
  builder_.add_m_name(m_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<icpEntityDataComponent> CreateicpEntityDataComponentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *m_name = nullptr,
    flatbuffers::Offset<Inception::fb::icpGuid> m_guid = 0) {
  auto m_name__ = m_name ? _fbb.CreateString(m_name) : 0;
  return Inception::fb::CreateicpEntityDataComponent(
      _fbb,
      m_name__,
      m_guid);
}

struct icpXFromComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef icpXFromComponentBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return icpXFromComponentTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_TRANSLATION = 4,
    VT_M_ROTATION = 6,
    VT_M_QUTERNIONROT = 8,
    VT_M_SCALE = 10
  };
  const Inception::fb::Vector3 *m_translation() const {
    return GetPointer<const Inception::fb::Vector3 *>(VT_M_TRANSLATION);
  }
  const Inception::fb::Vector3 *m_rotation() const {
    return GetPointer<const Inception::fb::Vector3 *>(VT_M_ROTATION);
  }
  const Inception::fb::Quaternion *m_quternionRot() const {
    return GetPointer<const Inception::fb::Quaternion *>(VT_M_QUTERNIONROT);
  }
  const Inception::fb::Vector3 *m_scale() const {
    return GetPointer<const Inception::fb::Vector3 *>(VT_M_SCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_M_TRANSLATION) &&
           verifier.VerifyTable(m_translation()) &&
           VerifyOffset(verifier, VT_M_ROTATION) &&
           verifier.VerifyTable(m_rotation()) &&
           VerifyOffset(verifier, VT_M_QUTERNIONROT) &&
           verifier.VerifyTable(m_quternionRot()) &&
           VerifyOffset(verifier, VT_M_SCALE) &&
           verifier.VerifyTable(m_scale()) &&
           verifier.EndTable();
  }
};

struct icpXFromComponentBuilder {
  typedef icpXFromComponent Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_translation(flatbuffers::Offset<Inception::fb::Vector3> m_translation) {
    fbb_.AddOffset(icpXFromComponent::VT_M_TRANSLATION, m_translation);
  }
  void add_m_rotation(flatbuffers::Offset<Inception::fb::Vector3> m_rotation) {
    fbb_.AddOffset(icpXFromComponent::VT_M_ROTATION, m_rotation);
  }
  void add_m_quternionRot(flatbuffers::Offset<Inception::fb::Quaternion> m_quternionRot) {
    fbb_.AddOffset(icpXFromComponent::VT_M_QUTERNIONROT, m_quternionRot);
  }
  void add_m_scale(flatbuffers::Offset<Inception::fb::Vector3> m_scale) {
    fbb_.AddOffset(icpXFromComponent::VT_M_SCALE, m_scale);
  }
  explicit icpXFromComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<icpXFromComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<icpXFromComponent>(end);
    return o;
  }
};

inline flatbuffers::Offset<icpXFromComponent> CreateicpXFromComponent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Inception::fb::Vector3> m_translation = 0,
    flatbuffers::Offset<Inception::fb::Vector3> m_rotation = 0,
    flatbuffers::Offset<Inception::fb::Quaternion> m_quternionRot = 0,
    flatbuffers::Offset<Inception::fb::Vector3> m_scale = 0) {
  icpXFromComponentBuilder builder_(_fbb);
  builder_.add_m_scale(m_scale);
  builder_.add_m_quternionRot(m_quternionRot);
  builder_.add_m_rotation(m_rotation);
  builder_.add_m_translation(m_translation);
  return builder_.Finish();
}

struct icpCameraComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef icpCameraComponentBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return icpCameraComponentTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_CLEARCOLOR = 4,
    VT_M_FOV = 6,
    VT_M_NEAR = 8,
    VT_M_FAR = 10,
    VT_M_CAMERASPEED = 12,
    VT_M_CAMERAROTATIONSPEED = 14,
    VT_M_VIEWDIR = 16,
    VT_M_UPDIR = 18
  };
  const Inception::fb::Vector3 *m_clearColor() const {
    return GetPointer<const Inception::fb::Vector3 *>(VT_M_CLEARCOLOR);
  }
  float m_fov() const {
    return GetField<float>(VT_M_FOV, 0.0f);
  }
  float m_near() const {
    return GetField<float>(VT_M_NEAR, 0.0f);
  }
  float m_far() const {
    return GetField<float>(VT_M_FAR, 0.0f);
  }
  float m_cameraSpeed() const {
    return GetField<float>(VT_M_CAMERASPEED, 0.0f);
  }
  float m_cameraRotationSpeed() const {
    return GetField<float>(VT_M_CAMERAROTATIONSPEED, 0.0f);
  }
  const Inception::fb::Vector3 *m_viewDir() const {
    return GetPointer<const Inception::fb::Vector3 *>(VT_M_VIEWDIR);
  }
  const Inception::fb::Vector3 *m_upDir() const {
    return GetPointer<const Inception::fb::Vector3 *>(VT_M_UPDIR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_M_CLEARCOLOR) &&
           verifier.VerifyTable(m_clearColor()) &&
           VerifyField<float>(verifier, VT_M_FOV, 4) &&
           VerifyField<float>(verifier, VT_M_NEAR, 4) &&
           VerifyField<float>(verifier, VT_M_FAR, 4) &&
           VerifyField<float>(verifier, VT_M_CAMERASPEED, 4) &&
           VerifyField<float>(verifier, VT_M_CAMERAROTATIONSPEED, 4) &&
           VerifyOffset(verifier, VT_M_VIEWDIR) &&
           verifier.VerifyTable(m_viewDir()) &&
           VerifyOffset(verifier, VT_M_UPDIR) &&
           verifier.VerifyTable(m_upDir()) &&
           verifier.EndTable();
  }
};

struct icpCameraComponentBuilder {
  typedef icpCameraComponent Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_clearColor(flatbuffers::Offset<Inception::fb::Vector3> m_clearColor) {
    fbb_.AddOffset(icpCameraComponent::VT_M_CLEARCOLOR, m_clearColor);
  }
  void add_m_fov(float m_fov) {
    fbb_.AddElement<float>(icpCameraComponent::VT_M_FOV, m_fov, 0.0f);
  }
  void add_m_near(float m_near) {
    fbb_.AddElement<float>(icpCameraComponent::VT_M_NEAR, m_near, 0.0f);
  }
  void add_m_far(float m_far) {
    fbb_.AddElement<float>(icpCameraComponent::VT_M_FAR, m_far, 0.0f);
  }
  void add_m_cameraSpeed(float m_cameraSpeed) {
    fbb_.AddElement<float>(icpCameraComponent::VT_M_CAMERASPEED, m_cameraSpeed, 0.0f);
  }
  void add_m_cameraRotationSpeed(float m_cameraRotationSpeed) {
    fbb_.AddElement<float>(icpCameraComponent::VT_M_CAMERAROTATIONSPEED, m_cameraRotationSpeed, 0.0f);
  }
  void add_m_viewDir(flatbuffers::Offset<Inception::fb::Vector3> m_viewDir) {
    fbb_.AddOffset(icpCameraComponent::VT_M_VIEWDIR, m_viewDir);
  }
  void add_m_upDir(flatbuffers::Offset<Inception::fb::Vector3> m_upDir) {
    fbb_.AddOffset(icpCameraComponent::VT_M_UPDIR, m_upDir);
  }
  explicit icpCameraComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<icpCameraComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<icpCameraComponent>(end);
    return o;
  }
};

inline flatbuffers::Offset<icpCameraComponent> CreateicpCameraComponent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Inception::fb::Vector3> m_clearColor = 0,
    float m_fov = 0.0f,
    float m_near = 0.0f,
    float m_far = 0.0f,
    float m_cameraSpeed = 0.0f,
    float m_cameraRotationSpeed = 0.0f,
    flatbuffers::Offset<Inception::fb::Vector3> m_viewDir = 0,
    flatbuffers::Offset<Inception::fb::Vector3> m_upDir = 0) {
  icpCameraComponentBuilder builder_(_fbb);
  builder_.add_m_upDir(m_upDir);
  builder_.add_m_viewDir(m_viewDir);
  builder_.add_m_cameraRotationSpeed(m_cameraRotationSpeed);
  builder_.add_m_cameraSpeed(m_cameraSpeed);
  builder_.add_m_far(m_far);
  builder_.add_m_near(m_near);
  builder_.add_m_fov(m_fov);
  builder_.add_m_clearColor(m_clearColor);
  return builder_.Finish();
}

struct icpMeshRendererComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef icpMeshRendererComponentBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return icpMeshRendererComponentTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_RESID = 4
  };
  const flatbuffers::String *m_resId() const {
    return GetPointer<const flatbuffers::String *>(VT_M_RESID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_M_RESID) &&
           verifier.VerifyString(m_resId()) &&
           verifier.EndTable();
  }
};

struct icpMeshRendererComponentBuilder {
  typedef icpMeshRendererComponent Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_resId(flatbuffers::Offset<flatbuffers::String> m_resId) {
    fbb_.AddOffset(icpMeshRendererComponent::VT_M_RESID, m_resId);
  }
  explicit icpMeshRendererComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<icpMeshRendererComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<icpMeshRendererComponent>(end);
    return o;
  }
};

inline flatbuffers::Offset<icpMeshRendererComponent> CreateicpMeshRendererComponent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> m_resId = 0) {
  icpMeshRendererComponentBuilder builder_(_fbb);
  builder_.add_m_resId(m_resId);
  return builder_.Finish();
}

inline flatbuffers::Offset<icpMeshRendererComponent> CreateicpMeshRendererComponentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *m_resId = nullptr) {
  auto m_resId__ = m_resId ? _fbb.CreateString(m_resId) : 0;
  return Inception::fb::CreateicpMeshRendererComponent(
      _fbb,
      m_resId__);
}

inline bool VerifyicpComponentBase(flatbuffers::Verifier &verifier, const void *obj, icpComponentBase type) {
  switch (type) {
    case icpComponentBase_NONE: {
      return true;
    }
    case icpComponentBase_icpEntityDataComponent: {
      auto ptr = reinterpret_cast<const Inception::fb::icpEntityDataComponent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case icpComponentBase_icpXFromComponent: {
      auto ptr = reinterpret_cast<const Inception::fb::icpXFromComponent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case icpComponentBase_icpCameraComponent: {
      auto ptr = reinterpret_cast<const Inception::fb::icpCameraComponent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case icpComponentBase_icpMeshRendererComponent: {
      auto ptr = reinterpret_cast<const Inception::fb::icpMeshRendererComponent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyicpComponentBaseVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyicpComponentBase(
        verifier,  values->Get(i), types->GetEnum<icpComponentBase>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *icpComponentBaseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Inception::fb::icpEntityDataComponentTypeTable,
    Inception::fb::icpXFromComponentTypeTable,
    Inception::fb::icpCameraComponentTypeTable,
    Inception::fb::icpMeshRendererComponentTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "icpEntityDataComponent",
    "icpXFromComponent",
    "icpCameraComponent",
    "icpMeshRendererComponent"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *icpGuidTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "m_guid"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vector3TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "x",
    "y",
    "z"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuaternionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "x",
    "y",
    "z",
    "w"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Matrix4x4TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "m_data0",
    "m_data1",
    "m_data2",
    "m_data3",
    "m_data4",
    "m_data5",
    "m_data6",
    "m_data7",
    "m_data8",
    "m_data9",
    "m_data10",
    "m_data11",
    "m_data12",
    "m_data13",
    "m_data14",
    "m_data15"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 16, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *icpEntityDataComponentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Inception::fb::icpGuidTypeTable
  };
  static const char * const names[] = {
    "m_name",
    "m_guid"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *icpXFromComponentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Inception::fb::Vector3TypeTable,
    Inception::fb::QuaternionTypeTable
  };
  static const char * const names[] = {
    "m_translation",
    "m_rotation",
    "m_quternionRot",
    "m_scale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *icpCameraComponentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Inception::fb::Vector3TypeTable
  };
  static const char * const names[] = {
    "m_clearColor",
    "m_fov",
    "m_near",
    "m_far",
    "m_cameraSpeed",
    "m_cameraRotationSpeed",
    "m_viewDir",
    "m_upDir"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 8, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *icpMeshRendererComponentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "m_resId"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace fb
}  // namespace Inception

#endif  // FLATBUFFERS_GENERATED_COMPONENT_INCEPTION_FB_H_
