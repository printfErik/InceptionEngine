// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMPONENT_INCEPTION_FB_H_
#define FLATBUFFERS_GENERATED_COMPONENT_INCEPTION_FB_H_

#include "flatbuffers/flatbuffers.h"

namespace inception {
namespace fb {

struct icpGuid;
struct icpGuidBuilder;
struct icpGuidT;

struct Vector3;
struct Vector3Builder;
struct Vector3T;

struct Matrix;
struct MatrixBuilder;
struct MatrixT;

struct Quaternion;
struct QuaternionBuilder;
struct QuaternionT;

struct icpEntityDataComponent;
struct icpEntityDataComponentBuilder;
struct icpEntityDataComponentT;

struct icpXFromComponent;
struct icpXFromComponentBuilder;
struct icpXFromComponentT;

struct icpCameraComponent;
struct icpCameraComponentBuilder;
struct icpCameraComponentT;

bool operator==(const icpGuidT &lhs, const icpGuidT &rhs);
bool operator!=(const icpGuidT &lhs, const icpGuidT &rhs);
bool operator==(const Vector3T &lhs, const Vector3T &rhs);
bool operator!=(const Vector3T &lhs, const Vector3T &rhs);
bool operator==(const MatrixT &lhs, const MatrixT &rhs);
bool operator!=(const MatrixT &lhs, const MatrixT &rhs);
bool operator==(const QuaternionT &lhs, const QuaternionT &rhs);
bool operator!=(const QuaternionT &lhs, const QuaternionT &rhs);
bool operator==(const icpEntityDataComponentT &lhs, const icpEntityDataComponentT &rhs);
bool operator!=(const icpEntityDataComponentT &lhs, const icpEntityDataComponentT &rhs);
bool operator==(const icpXFromComponentT &lhs, const icpXFromComponentT &rhs);
bool operator!=(const icpXFromComponentT &lhs, const icpXFromComponentT &rhs);
bool operator==(const icpCameraComponentT &lhs, const icpCameraComponentT &rhs);
bool operator!=(const icpCameraComponentT &lhs, const icpCameraComponentT &rhs);

inline const flatbuffers::TypeTable *icpGuidTypeTable();

inline const flatbuffers::TypeTable *Vector3TypeTable();

inline const flatbuffers::TypeTable *MatrixTypeTable();

inline const flatbuffers::TypeTable *QuaternionTypeTable();

inline const flatbuffers::TypeTable *icpEntityDataComponentTypeTable();

inline const flatbuffers::TypeTable *icpXFromComponentTypeTable();

inline const flatbuffers::TypeTable *icpCameraComponentTypeTable();

struct icpGuidT {
  typedef icpGuid TableType;
  uint64_t m_guid = 0;
};

struct icpGuid FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef icpGuidT NativeTableType;
  typedef icpGuidBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return icpGuidTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_GUID = 4
  };
  uint64_t m_guid() const {
    return GetField<uint64_t>(VT_M_GUID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_M_GUID, 8) &&
           verifier.EndTable();
  }
  icpGuidT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(icpGuidT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<icpGuid> Pack(flatbuffers::FlatBufferBuilder &_fbb, const icpGuidT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct icpGuidBuilder {
  typedef icpGuid Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_guid(uint64_t m_guid) {
    fbb_.AddElement<uint64_t>(icpGuid::VT_M_GUID, m_guid, 0);
  }
  explicit icpGuidBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<icpGuid> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<icpGuid>(end);
    return o;
  }
};

inline flatbuffers::Offset<icpGuid> CreateicpGuid(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t m_guid = 0) {
  icpGuidBuilder builder_(_fbb);
  builder_.add_m_guid(m_guid);
  return builder_.Finish();
}

flatbuffers::Offset<icpGuid> PackicpGuid(flatbuffers::FlatBufferBuilder &_fbb, const icpGuidT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Vector3T {
  typedef Vector3 TableType;
  float x = 0.0f;
  float y = 0.0f;
  float z = 0.0f;
};

struct Vector3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Vector3T NativeTableType;
  typedef Vector3Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vector3TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           verifier.EndTable();
  }
  Vector3T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Vector3T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Vector3> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Vector3Builder {
  typedef Vector3 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Vector3::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Vector3::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Vector3::VT_Z, z, 0.0f);
  }
  explicit Vector3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Vector3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector3>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector3> CreateVector3(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  Vector3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

flatbuffers::Offset<Vector3> PackVector3(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatrixT {
  typedef Matrix TableType;
  float x = 0.0f;
  float y = 0.0f;
  float z = 0.0f;
};

struct Matrix FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatrixT NativeTableType;
  typedef MatrixBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MatrixTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           verifier.EndTable();
  }
  MatrixT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatrixT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Matrix> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatrixBuilder {
  typedef Matrix Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Matrix::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Matrix::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Matrix::VT_Z, z, 0.0f);
  }
  explicit MatrixBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Matrix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Matrix>(end);
    return o;
  }
};

inline flatbuffers::Offset<Matrix> CreateMatrix(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  MatrixBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

flatbuffers::Offset<Matrix> PackMatrix(flatbuffers::FlatBufferBuilder &_fbb, const MatrixT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QuaternionT {
  typedef Quaternion TableType;
  float x = 0.0f;
  float y = 0.0f;
  float z = 0.0f;
  float w = 0.0f;
};

struct Quaternion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuaternionT NativeTableType;
  typedef QuaternionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuaternionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8,
    VT_W = 10
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  float w() const {
    return GetField<float>(VT_W, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           VerifyField<float>(verifier, VT_W, 4) &&
           verifier.EndTable();
  }
  QuaternionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuaternionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Quaternion> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuaternionBuilder {
  typedef Quaternion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Quaternion::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Quaternion::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Quaternion::VT_Z, z, 0.0f);
  }
  void add_w(float w) {
    fbb_.AddElement<float>(Quaternion::VT_W, w, 0.0f);
  }
  explicit QuaternionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quaternion> CreateQuaternion(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f,
    float w = 0.0f) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_w(w);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

flatbuffers::Offset<Quaternion> PackQuaternion(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct icpEntityDataComponentT {
  typedef icpEntityDataComponent TableType;
  std::string m_name{};
  --filename-suffix<inception::fb::icpGuidT> m_guid{};
  icpEntityDataComponentT() = default;
  icpEntityDataComponentT(const icpEntityDataComponentT &o);
  icpEntityDataComponentT(icpEntityDataComponentT&&) FLATBUFFERS_NOEXCEPT = default;
  icpEntityDataComponentT &operator=(icpEntityDataComponentT o) FLATBUFFERS_NOEXCEPT;
};

struct icpEntityDataComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef icpEntityDataComponentT NativeTableType;
  typedef icpEntityDataComponentBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return icpEntityDataComponentTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_NAME = 4,
    VT_M_GUID = 6
  };
  const flatbuffers::String *m_name() const {
    return GetPointer<const flatbuffers::String *>(VT_M_NAME);
  }
  const inception::fb::icpGuid *m_guid() const {
    return GetPointer<const inception::fb::icpGuid *>(VT_M_GUID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_M_NAME) &&
           verifier.VerifyString(m_name()) &&
           VerifyOffset(verifier, VT_M_GUID) &&
           verifier.VerifyTable(m_guid()) &&
           verifier.EndTable();
  }
  icpEntityDataComponentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(icpEntityDataComponentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<icpEntityDataComponent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const icpEntityDataComponentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct icpEntityDataComponentBuilder {
  typedef icpEntityDataComponent Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_name(flatbuffers::Offset<flatbuffers::String> m_name) {
    fbb_.AddOffset(icpEntityDataComponent::VT_M_NAME, m_name);
  }
  void add_m_guid(flatbuffers::Offset<inception::fb::icpGuid> m_guid) {
    fbb_.AddOffset(icpEntityDataComponent::VT_M_GUID, m_guid);
  }
  explicit icpEntityDataComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<icpEntityDataComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<icpEntityDataComponent>(end);
    return o;
  }
};

inline flatbuffers::Offset<icpEntityDataComponent> CreateicpEntityDataComponent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> m_name = 0,
    flatbuffers::Offset<inception::fb::icpGuid> m_guid = 0) {
  icpEntityDataComponentBuilder builder_(_fbb);
  builder_.add_m_guid(m_guid);
  builder_.add_m_name(m_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<icpEntityDataComponent> CreateicpEntityDataComponentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *m_name = nullptr,
    flatbuffers::Offset<inception::fb::icpGuid> m_guid = 0) {
  auto m_name__ = m_name ? _fbb.CreateString(m_name) : 0;
  return inception::fb::CreateicpEntityDataComponent(
      _fbb,
      m_name__,
      m_guid);
}

flatbuffers::Offset<icpEntityDataComponent> PackicpEntityDataComponent(flatbuffers::FlatBufferBuilder &_fbb, const icpEntityDataComponentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct icpXFromComponentT {
  typedef icpXFromComponent TableType;
  --filename-suffix<inception::fb::Vector3T> m_translation{};
  --filename-suffix<inception::fb::Vector3T> m_rotation{};
  --filename-suffix<inception::fb::QuaternionT> m_quternionRot{};
  --filename-suffix<inception::fb::Vector3T> m_scale{};
  icpXFromComponentT() = default;
  icpXFromComponentT(const icpXFromComponentT &o);
  icpXFromComponentT(icpXFromComponentT&&) FLATBUFFERS_NOEXCEPT = default;
  icpXFromComponentT &operator=(icpXFromComponentT o) FLATBUFFERS_NOEXCEPT;
};

struct icpXFromComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef icpXFromComponentT NativeTableType;
  typedef icpXFromComponentBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return icpXFromComponentTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_TRANSLATION = 4,
    VT_M_ROTATION = 6,
    VT_M_QUTERNIONROT = 8,
    VT_M_SCALE = 10
  };
  const inception::fb::Vector3 *m_translation() const {
    return GetPointer<const inception::fb::Vector3 *>(VT_M_TRANSLATION);
  }
  const inception::fb::Vector3 *m_rotation() const {
    return GetPointer<const inception::fb::Vector3 *>(VT_M_ROTATION);
  }
  const inception::fb::Quaternion *m_quternionRot() const {
    return GetPointer<const inception::fb::Quaternion *>(VT_M_QUTERNIONROT);
  }
  const inception::fb::Vector3 *m_scale() const {
    return GetPointer<const inception::fb::Vector3 *>(VT_M_SCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_M_TRANSLATION) &&
           verifier.VerifyTable(m_translation()) &&
           VerifyOffset(verifier, VT_M_ROTATION) &&
           verifier.VerifyTable(m_rotation()) &&
           VerifyOffset(verifier, VT_M_QUTERNIONROT) &&
           verifier.VerifyTable(m_quternionRot()) &&
           VerifyOffset(verifier, VT_M_SCALE) &&
           verifier.VerifyTable(m_scale()) &&
           verifier.EndTable();
  }
  icpXFromComponentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(icpXFromComponentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<icpXFromComponent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const icpXFromComponentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct icpXFromComponentBuilder {
  typedef icpXFromComponent Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_translation(flatbuffers::Offset<inception::fb::Vector3> m_translation) {
    fbb_.AddOffset(icpXFromComponent::VT_M_TRANSLATION, m_translation);
  }
  void add_m_rotation(flatbuffers::Offset<inception::fb::Vector3> m_rotation) {
    fbb_.AddOffset(icpXFromComponent::VT_M_ROTATION, m_rotation);
  }
  void add_m_quternionRot(flatbuffers::Offset<inception::fb::Quaternion> m_quternionRot) {
    fbb_.AddOffset(icpXFromComponent::VT_M_QUTERNIONROT, m_quternionRot);
  }
  void add_m_scale(flatbuffers::Offset<inception::fb::Vector3> m_scale) {
    fbb_.AddOffset(icpXFromComponent::VT_M_SCALE, m_scale);
  }
  explicit icpXFromComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<icpXFromComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<icpXFromComponent>(end);
    return o;
  }
};

inline flatbuffers::Offset<icpXFromComponent> CreateicpXFromComponent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<inception::fb::Vector3> m_translation = 0,
    flatbuffers::Offset<inception::fb::Vector3> m_rotation = 0,
    flatbuffers::Offset<inception::fb::Quaternion> m_quternionRot = 0,
    flatbuffers::Offset<inception::fb::Vector3> m_scale = 0) {
  icpXFromComponentBuilder builder_(_fbb);
  builder_.add_m_scale(m_scale);
  builder_.add_m_quternionRot(m_quternionRot);
  builder_.add_m_rotation(m_rotation);
  builder_.add_m_translation(m_translation);
  return builder_.Finish();
}

flatbuffers::Offset<icpXFromComponent> PackicpXFromComponent(flatbuffers::FlatBufferBuilder &_fbb, const icpXFromComponentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct icpCameraComponentT {
  typedef icpCameraComponent TableType;
  --filename-suffix<inception::fb::Vector3T> m_clearColor{};
  float m_fov = 0.0f;
  float m_aspectRatio = 0.0f;
  float m_near = 0.0f;
  float m_far = 0.0f;
  --filename-suffix<inception::fb::Vector3T> m_position{};
  --filename-suffix<inception::fb::QuaternionT> m_rotation{};
  --filename-suffix<inception::fb::MatrixT> m_viewMatrix{};
  float m_cameraSpeed = 0.0f;
  icpCameraComponentT() = default;
  icpCameraComponentT(const icpCameraComponentT &o);
  icpCameraComponentT(icpCameraComponentT&&) FLATBUFFERS_NOEXCEPT = default;
  icpCameraComponentT &operator=(icpCameraComponentT o) FLATBUFFERS_NOEXCEPT;
};

struct icpCameraComponent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef icpCameraComponentT NativeTableType;
  typedef icpCameraComponentBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return icpCameraComponentTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_M_CLEARCOLOR = 4,
    VT_M_FOV = 6,
    VT_M_ASPECTRATIO = 8,
    VT_M_NEAR = 10,
    VT_M_FAR = 12,
    VT_M_POSITION = 14,
    VT_M_ROTATION = 16,
    VT_M_VIEWMATRIX = 18,
    VT_M_CAMERASPEED = 20
  };
  const inception::fb::Vector3 *m_clearColor() const {
    return GetPointer<const inception::fb::Vector3 *>(VT_M_CLEARCOLOR);
  }
  float m_fov() const {
    return GetField<float>(VT_M_FOV, 0.0f);
  }
  float m_aspectRatio() const {
    return GetField<float>(VT_M_ASPECTRATIO, 0.0f);
  }
  float m_near() const {
    return GetField<float>(VT_M_NEAR, 0.0f);
  }
  float m_far() const {
    return GetField<float>(VT_M_FAR, 0.0f);
  }
  const inception::fb::Vector3 *m_position() const {
    return GetPointer<const inception::fb::Vector3 *>(VT_M_POSITION);
  }
  const inception::fb::Quaternion *m_rotation() const {
    return GetPointer<const inception::fb::Quaternion *>(VT_M_ROTATION);
  }
  const inception::fb::Matrix *m_viewMatrix() const {
    return GetPointer<const inception::fb::Matrix *>(VT_M_VIEWMATRIX);
  }
  float m_cameraSpeed() const {
    return GetField<float>(VT_M_CAMERASPEED, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_M_CLEARCOLOR) &&
           verifier.VerifyTable(m_clearColor()) &&
           VerifyField<float>(verifier, VT_M_FOV, 4) &&
           VerifyField<float>(verifier, VT_M_ASPECTRATIO, 4) &&
           VerifyField<float>(verifier, VT_M_NEAR, 4) &&
           VerifyField<float>(verifier, VT_M_FAR, 4) &&
           VerifyOffset(verifier, VT_M_POSITION) &&
           verifier.VerifyTable(m_position()) &&
           VerifyOffset(verifier, VT_M_ROTATION) &&
           verifier.VerifyTable(m_rotation()) &&
           VerifyOffset(verifier, VT_M_VIEWMATRIX) &&
           verifier.VerifyTable(m_viewMatrix()) &&
           VerifyField<float>(verifier, VT_M_CAMERASPEED, 4) &&
           verifier.EndTable();
  }
  icpCameraComponentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(icpCameraComponentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<icpCameraComponent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const icpCameraComponentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct icpCameraComponentBuilder {
  typedef icpCameraComponent Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_m_clearColor(flatbuffers::Offset<inception::fb::Vector3> m_clearColor) {
    fbb_.AddOffset(icpCameraComponent::VT_M_CLEARCOLOR, m_clearColor);
  }
  void add_m_fov(float m_fov) {
    fbb_.AddElement<float>(icpCameraComponent::VT_M_FOV, m_fov, 0.0f);
  }
  void add_m_aspectRatio(float m_aspectRatio) {
    fbb_.AddElement<float>(icpCameraComponent::VT_M_ASPECTRATIO, m_aspectRatio, 0.0f);
  }
  void add_m_near(float m_near) {
    fbb_.AddElement<float>(icpCameraComponent::VT_M_NEAR, m_near, 0.0f);
  }
  void add_m_far(float m_far) {
    fbb_.AddElement<float>(icpCameraComponent::VT_M_FAR, m_far, 0.0f);
  }
  void add_m_position(flatbuffers::Offset<inception::fb::Vector3> m_position) {
    fbb_.AddOffset(icpCameraComponent::VT_M_POSITION, m_position);
  }
  void add_m_rotation(flatbuffers::Offset<inception::fb::Quaternion> m_rotation) {
    fbb_.AddOffset(icpCameraComponent::VT_M_ROTATION, m_rotation);
  }
  void add_m_viewMatrix(flatbuffers::Offset<inception::fb::Matrix> m_viewMatrix) {
    fbb_.AddOffset(icpCameraComponent::VT_M_VIEWMATRIX, m_viewMatrix);
  }
  void add_m_cameraSpeed(float m_cameraSpeed) {
    fbb_.AddElement<float>(icpCameraComponent::VT_M_CAMERASPEED, m_cameraSpeed, 0.0f);
  }
  explicit icpCameraComponentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<icpCameraComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<icpCameraComponent>(end);
    return o;
  }
};

inline flatbuffers::Offset<icpCameraComponent> CreateicpCameraComponent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<inception::fb::Vector3> m_clearColor = 0,
    float m_fov = 0.0f,
    float m_aspectRatio = 0.0f,
    float m_near = 0.0f,
    float m_far = 0.0f,
    flatbuffers::Offset<inception::fb::Vector3> m_position = 0,
    flatbuffers::Offset<inception::fb::Quaternion> m_rotation = 0,
    flatbuffers::Offset<inception::fb::Matrix> m_viewMatrix = 0,
    float m_cameraSpeed = 0.0f) {
  icpCameraComponentBuilder builder_(_fbb);
  builder_.add_m_cameraSpeed(m_cameraSpeed);
  builder_.add_m_viewMatrix(m_viewMatrix);
  builder_.add_m_rotation(m_rotation);
  builder_.add_m_position(m_position);
  builder_.add_m_far(m_far);
  builder_.add_m_near(m_near);
  builder_.add_m_aspectRatio(m_aspectRatio);
  builder_.add_m_fov(m_fov);
  builder_.add_m_clearColor(m_clearColor);
  return builder_.Finish();
}

flatbuffers::Offset<icpCameraComponent> PackicpCameraComponent(flatbuffers::FlatBufferBuilder &_fbb, const icpCameraComponentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const icpGuidT &lhs, const icpGuidT &rhs) {
  return
      (lhs.m_guid == rhs.m_guid);
}

inline bool operator!=(const icpGuidT &lhs, const icpGuidT &rhs) {
    return !(lhs == rhs);
}


inline icpGuidT *icpGuid::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<icpGuidT>(new icpGuidT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void icpGuid::UnPackTo(icpGuidT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = m_guid(); _o->m_guid = _e; }
}

inline flatbuffers::Offset<icpGuid> icpGuid::Pack(flatbuffers::FlatBufferBuilder &_fbb, const icpGuidT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return PackicpGuid(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<icpGuid> PackicpGuid(flatbuffers::FlatBufferBuilder &_fbb, const icpGuidT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const icpGuidT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _m_guid = _o->m_guid;
  return inception::fb::CreateicpGuid(
      _fbb,
      _m_guid);
}


inline bool operator==(const Vector3T &lhs, const Vector3T &rhs) {
  return
      (lhs.x == rhs.x) &&
      (lhs.y == rhs.y) &&
      (lhs.z == rhs.z);
}

inline bool operator!=(const Vector3T &lhs, const Vector3T &rhs) {
    return !(lhs == rhs);
}


inline Vector3T *Vector3::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Vector3T>(new Vector3T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Vector3::UnPackTo(Vector3T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
}

inline flatbuffers::Offset<Vector3> Vector3::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return PackVector3(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Vector3> PackVector3(flatbuffers::FlatBufferBuilder &_fbb, const Vector3T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Vector3T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return inception::fb::CreateVector3(
      _fbb,
      _x,
      _y,
      _z);
}


inline bool operator==(const MatrixT &lhs, const MatrixT &rhs) {
  return
      (lhs.x == rhs.x) &&
      (lhs.y == rhs.y) &&
      (lhs.z == rhs.z);
}

inline bool operator!=(const MatrixT &lhs, const MatrixT &rhs) {
    return !(lhs == rhs);
}


inline MatrixT *Matrix::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MatrixT>(new MatrixT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Matrix::UnPackTo(MatrixT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
}

inline flatbuffers::Offset<Matrix> Matrix::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatrixT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return PackMatrix(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Matrix> PackMatrix(flatbuffers::FlatBufferBuilder &_fbb, const MatrixT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatrixT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  return inception::fb::CreateMatrix(
      _fbb,
      _x,
      _y,
      _z);
}


inline bool operator==(const QuaternionT &lhs, const QuaternionT &rhs) {
  return
      (lhs.x == rhs.x) &&
      (lhs.y == rhs.y) &&
      (lhs.z == rhs.z) &&
      (lhs.w == rhs.w);
}

inline bool operator!=(const QuaternionT &lhs, const QuaternionT &rhs) {
    return !(lhs == rhs);
}


inline QuaternionT *Quaternion::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QuaternionT>(new QuaternionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Quaternion::UnPackTo(QuaternionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = z(); _o->z = _e; }
  { auto _e = w(); _o->w = _e; }
}

inline flatbuffers::Offset<Quaternion> Quaternion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return PackQuaternion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Quaternion> PackQuaternion(flatbuffers::FlatBufferBuilder &_fbb, const QuaternionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuaternionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _z = _o->z;
  auto _w = _o->w;
  return inception::fb::CreateQuaternion(
      _fbb,
      _x,
      _y,
      _z,
      _w);
}


inline bool operator==(const icpEntityDataComponentT &lhs, const icpEntityDataComponentT &rhs) {
  return
      (lhs.m_name == rhs.m_name) &&
      ((lhs.m_guid == rhs.m_guid) || (lhs.m_guid && rhs.m_guid && *lhs.m_guid == *rhs.m_guid));
}

inline bool operator!=(const icpEntityDataComponentT &lhs, const icpEntityDataComponentT &rhs) {
    return !(lhs == rhs);
}


inline icpEntityDataComponentT::icpEntityDataComponentT(const icpEntityDataComponentT &o)
      : m_name(o.m_name),
        m_guid((o.m_guid) ? new inception::fb::icpGuidT(*o.m_guid) : nullptr) {
}

inline icpEntityDataComponentT &icpEntityDataComponentT::operator=(icpEntityDataComponentT o) FLATBUFFERS_NOEXCEPT {
  std::swap(m_name, o.m_name);
  std::swap(m_guid, o.m_guid);
  return *this;
}

inline icpEntityDataComponentT *icpEntityDataComponent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<icpEntityDataComponentT>(new icpEntityDataComponentT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void icpEntityDataComponent::UnPackTo(icpEntityDataComponentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = m_name(); if (_e) _o->m_name = _e->str(); }
  { auto _e = m_guid(); if (_e) { if(_o->m_guid) { _e->UnPackTo(_o->m_guid.get(), _resolver); } else { _o->m_guid = --filename-suffix<inception::fb::icpGuidT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<icpEntityDataComponent> icpEntityDataComponent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const icpEntityDataComponentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return PackicpEntityDataComponent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<icpEntityDataComponent> PackicpEntityDataComponent(flatbuffers::FlatBufferBuilder &_fbb, const icpEntityDataComponentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const icpEntityDataComponentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _m_name = _o->m_name.empty() ? 0 : _fbb.CreateString(_o->m_name);
  auto _m_guid = _o->m_guid ? PackicpGuid(_fbb, _o->m_guid.get(), _rehasher) : 0;
  return inception::fb::CreateicpEntityDataComponent(
      _fbb,
      _m_name,
      _m_guid);
}


inline bool operator==(const icpXFromComponentT &lhs, const icpXFromComponentT &rhs) {
  return
      ((lhs.m_translation == rhs.m_translation) || (lhs.m_translation && rhs.m_translation && *lhs.m_translation == *rhs.m_translation)) &&
      ((lhs.m_rotation == rhs.m_rotation) || (lhs.m_rotation && rhs.m_rotation && *lhs.m_rotation == *rhs.m_rotation)) &&
      ((lhs.m_quternionRot == rhs.m_quternionRot) || (lhs.m_quternionRot && rhs.m_quternionRot && *lhs.m_quternionRot == *rhs.m_quternionRot)) &&
      ((lhs.m_scale == rhs.m_scale) || (lhs.m_scale && rhs.m_scale && *lhs.m_scale == *rhs.m_scale));
}

inline bool operator!=(const icpXFromComponentT &lhs, const icpXFromComponentT &rhs) {
    return !(lhs == rhs);
}


inline icpXFromComponentT::icpXFromComponentT(const icpXFromComponentT &o)
      : m_translation((o.m_translation) ? new inception::fb::Vector3T(*o.m_translation) : nullptr),
        m_rotation((o.m_rotation) ? new inception::fb::Vector3T(*o.m_rotation) : nullptr),
        m_quternionRot((o.m_quternionRot) ? new inception::fb::QuaternionT(*o.m_quternionRot) : nullptr),
        m_scale((o.m_scale) ? new inception::fb::Vector3T(*o.m_scale) : nullptr) {
}

inline icpXFromComponentT &icpXFromComponentT::operator=(icpXFromComponentT o) FLATBUFFERS_NOEXCEPT {
  std::swap(m_translation, o.m_translation);
  std::swap(m_rotation, o.m_rotation);
  std::swap(m_quternionRot, o.m_quternionRot);
  std::swap(m_scale, o.m_scale);
  return *this;
}

inline icpXFromComponentT *icpXFromComponent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<icpXFromComponentT>(new icpXFromComponentT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void icpXFromComponent::UnPackTo(icpXFromComponentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = m_translation(); if (_e) { if(_o->m_translation) { _e->UnPackTo(_o->m_translation.get(), _resolver); } else { _o->m_translation = --filename-suffix<inception::fb::Vector3T>(_e->UnPack(_resolver)); } } }
  { auto _e = m_rotation(); if (_e) { if(_o->m_rotation) { _e->UnPackTo(_o->m_rotation.get(), _resolver); } else { _o->m_rotation = --filename-suffix<inception::fb::Vector3T>(_e->UnPack(_resolver)); } } }
  { auto _e = m_quternionRot(); if (_e) { if(_o->m_quternionRot) { _e->UnPackTo(_o->m_quternionRot.get(), _resolver); } else { _o->m_quternionRot = --filename-suffix<inception::fb::QuaternionT>(_e->UnPack(_resolver)); } } }
  { auto _e = m_scale(); if (_e) { if(_o->m_scale) { _e->UnPackTo(_o->m_scale.get(), _resolver); } else { _o->m_scale = --filename-suffix<inception::fb::Vector3T>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<icpXFromComponent> icpXFromComponent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const icpXFromComponentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return PackicpXFromComponent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<icpXFromComponent> PackicpXFromComponent(flatbuffers::FlatBufferBuilder &_fbb, const icpXFromComponentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const icpXFromComponentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _m_translation = _o->m_translation ? PackVector3(_fbb, _o->m_translation.get(), _rehasher) : 0;
  auto _m_rotation = _o->m_rotation ? PackVector3(_fbb, _o->m_rotation.get(), _rehasher) : 0;
  auto _m_quternionRot = _o->m_quternionRot ? PackQuaternion(_fbb, _o->m_quternionRot.get(), _rehasher) : 0;
  auto _m_scale = _o->m_scale ? PackVector3(_fbb, _o->m_scale.get(), _rehasher) : 0;
  return inception::fb::CreateicpXFromComponent(
      _fbb,
      _m_translation,
      _m_rotation,
      _m_quternionRot,
      _m_scale);
}


inline bool operator==(const icpCameraComponentT &lhs, const icpCameraComponentT &rhs) {
  return
      ((lhs.m_clearColor == rhs.m_clearColor) || (lhs.m_clearColor && rhs.m_clearColor && *lhs.m_clearColor == *rhs.m_clearColor)) &&
      (lhs.m_fov == rhs.m_fov) &&
      (lhs.m_aspectRatio == rhs.m_aspectRatio) &&
      (lhs.m_near == rhs.m_near) &&
      (lhs.m_far == rhs.m_far) &&
      ((lhs.m_position == rhs.m_position) || (lhs.m_position && rhs.m_position && *lhs.m_position == *rhs.m_position)) &&
      ((lhs.m_rotation == rhs.m_rotation) || (lhs.m_rotation && rhs.m_rotation && *lhs.m_rotation == *rhs.m_rotation)) &&
      ((lhs.m_viewMatrix == rhs.m_viewMatrix) || (lhs.m_viewMatrix && rhs.m_viewMatrix && *lhs.m_viewMatrix == *rhs.m_viewMatrix)) &&
      (lhs.m_cameraSpeed == rhs.m_cameraSpeed);
}

inline bool operator!=(const icpCameraComponentT &lhs, const icpCameraComponentT &rhs) {
    return !(lhs == rhs);
}


inline icpCameraComponentT::icpCameraComponentT(const icpCameraComponentT &o)
      : m_clearColor((o.m_clearColor) ? new inception::fb::Vector3T(*o.m_clearColor) : nullptr),
        m_fov(o.m_fov),
        m_aspectRatio(o.m_aspectRatio),
        m_near(o.m_near),
        m_far(o.m_far),
        m_position((o.m_position) ? new inception::fb::Vector3T(*o.m_position) : nullptr),
        m_rotation((o.m_rotation) ? new inception::fb::QuaternionT(*o.m_rotation) : nullptr),
        m_viewMatrix((o.m_viewMatrix) ? new inception::fb::MatrixT(*o.m_viewMatrix) : nullptr),
        m_cameraSpeed(o.m_cameraSpeed) {
}

inline icpCameraComponentT &icpCameraComponentT::operator=(icpCameraComponentT o) FLATBUFFERS_NOEXCEPT {
  std::swap(m_clearColor, o.m_clearColor);
  std::swap(m_fov, o.m_fov);
  std::swap(m_aspectRatio, o.m_aspectRatio);
  std::swap(m_near, o.m_near);
  std::swap(m_far, o.m_far);
  std::swap(m_position, o.m_position);
  std::swap(m_rotation, o.m_rotation);
  std::swap(m_viewMatrix, o.m_viewMatrix);
  std::swap(m_cameraSpeed, o.m_cameraSpeed);
  return *this;
}

inline icpCameraComponentT *icpCameraComponent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<icpCameraComponentT>(new icpCameraComponentT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void icpCameraComponent::UnPackTo(icpCameraComponentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = m_clearColor(); if (_e) { if(_o->m_clearColor) { _e->UnPackTo(_o->m_clearColor.get(), _resolver); } else { _o->m_clearColor = --filename-suffix<inception::fb::Vector3T>(_e->UnPack(_resolver)); } } }
  { auto _e = m_fov(); _o->m_fov = _e; }
  { auto _e = m_aspectRatio(); _o->m_aspectRatio = _e; }
  { auto _e = m_near(); _o->m_near = _e; }
  { auto _e = m_far(); _o->m_far = _e; }
  { auto _e = m_position(); if (_e) { if(_o->m_position) { _e->UnPackTo(_o->m_position.get(), _resolver); } else { _o->m_position = --filename-suffix<inception::fb::Vector3T>(_e->UnPack(_resolver)); } } }
  { auto _e = m_rotation(); if (_e) { if(_o->m_rotation) { _e->UnPackTo(_o->m_rotation.get(), _resolver); } else { _o->m_rotation = --filename-suffix<inception::fb::QuaternionT>(_e->UnPack(_resolver)); } } }
  { auto _e = m_viewMatrix(); if (_e) { if(_o->m_viewMatrix) { _e->UnPackTo(_o->m_viewMatrix.get(), _resolver); } else { _o->m_viewMatrix = --filename-suffix<inception::fb::MatrixT>(_e->UnPack(_resolver)); } } }
  { auto _e = m_cameraSpeed(); _o->m_cameraSpeed = _e; }
}

inline flatbuffers::Offset<icpCameraComponent> icpCameraComponent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const icpCameraComponentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return PackicpCameraComponent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<icpCameraComponent> PackicpCameraComponent(flatbuffers::FlatBufferBuilder &_fbb, const icpCameraComponentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const icpCameraComponentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _m_clearColor = _o->m_clearColor ? PackVector3(_fbb, _o->m_clearColor.get(), _rehasher) : 0;
  auto _m_fov = _o->m_fov;
  auto _m_aspectRatio = _o->m_aspectRatio;
  auto _m_near = _o->m_near;
  auto _m_far = _o->m_far;
  auto _m_position = _o->m_position ? PackVector3(_fbb, _o->m_position.get(), _rehasher) : 0;
  auto _m_rotation = _o->m_rotation ? PackQuaternion(_fbb, _o->m_rotation.get(), _rehasher) : 0;
  auto _m_viewMatrix = _o->m_viewMatrix ? PackMatrix(_fbb, _o->m_viewMatrix.get(), _rehasher) : 0;
  auto _m_cameraSpeed = _o->m_cameraSpeed;
  return inception::fb::CreateicpCameraComponent(
      _fbb,
      _m_clearColor,
      _m_fov,
      _m_aspectRatio,
      _m_near,
      _m_far,
      _m_position,
      _m_rotation,
      _m_viewMatrix,
      _m_cameraSpeed);
}

inline const flatbuffers::TypeTable *icpGuidTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "m_guid"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Vector3TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "x",
    "y",
    "z"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MatrixTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "x",
    "y",
    "z"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuaternionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "x",
    "y",
    "z",
    "w"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *icpEntityDataComponentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    inception::fb::icpGuidTypeTable
  };
  static const char * const names[] = {
    "m_name",
    "m_guid"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *icpXFromComponentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    inception::fb::Vector3TypeTable,
    inception::fb::QuaternionTypeTable
  };
  static const char * const names[] = {
    "m_translation",
    "m_rotation",
    "m_quternionRot",
    "m_scale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *icpCameraComponentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    inception::fb::Vector3TypeTable,
    inception::fb::QuaternionTypeTable,
    inception::fb::MatrixTypeTable
  };
  static const char * const names[] = {
    "m_clearColor",
    "m_fov",
    "m_aspectRatio",
    "m_near",
    "m_far",
    "m_position",
    "m_rotation",
    "m_viewMatrix",
    "m_cameraSpeed"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace fb
}  // namespace inception

#endif  // FLATBUFFERS_GENERATED_COMPONENT_INCEPTION_FB_H_
